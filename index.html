<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gaga Ball</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
canvas {
  border-radius: 8px;
  box-shadow: 0 0 40px rgba(0,0,0,0.5);
  max-height: 100vh;
  max-width: 100vw;
  object-fit: contain;
}
#touch-controls {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 10px 15px 20px;
  z-index: 10;
  pointer-events: none;
  justify-content: space-between;
  align-items: flex-end;
}
#touch-controls.visible { display: flex; }
.touch-group {
  display: flex;
  gap: 10px;
  pointer-events: auto;
}
.touch-group.right-group {
  flex-direction: column;
  align-items: flex-end;
  gap: 10px;
}
.touch-btn {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  border: 3px solid rgba(255,255,255,0.4);
  background: rgba(255,255,255,0.1);
  color: rgba(255,255,255,0.7);
  font-size: 22px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;
  pointer-events: auto;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}
.touch-btn:active, .touch-btn.pressed {
  background: rgba(255,255,255,0.3);
  border-color: rgba(255,255,255,0.7);
}
.touch-btn.hit-btn {
  width: 80px;
  height: 80px;
  font-size: 16px;
  border-color: rgba(255,87,34,0.6);
  background: rgba(255,87,34,0.15);
}
.touch-btn.hit-btn:active, .touch-btn.hit-btn.pressed {
  background: rgba(255,87,34,0.4);
  border-color: rgba(255,87,34,0.9);
}
.touch-btn.jump-btn {
  width: 64px;
  height: 64px;
  border-color: rgba(76,175,80,0.6);
  background: rgba(76,175,80,0.12);
}
.touch-btn.jump-btn:active, .touch-btn.jump-btn.pressed {
  background: rgba(76,175,80,0.35);
  border-color: rgba(76,175,80,0.9);
}
#touch-menu {
  display: none;
  position: fixed;
  bottom: 30px;
  left: 0;
  right: 0;
  z-index: 10;
  pointer-events: none;
  text-align: center;
}
#touch-menu.visible { display: block; }
.menu-touch-btn {
  padding: 14px 32px;
  margin: 6px;
  border-radius: 12px;
  border: 2px solid rgba(255,255,255,0.4);
  background: rgba(255,255,255,0.1);
  color: rgba(255,255,255,0.8);
  font-size: 17px;
  font-weight: bold;
  font-family: inherit;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;
  pointer-events: auto;
  display: inline-block;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}
.menu-touch-btn:active { background: rgba(255,255,255,0.3); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- Touch controls for gameplay -->
<div id="touch-controls">
  <div class="touch-group">
    <button class="touch-btn" id="btn-left">&#9664;</button>
    <button class="touch-btn" id="btn-right">&#9654;</button>
  </div>
  <div class="touch-group right-group">
    <div class="ability-row" id="ability-buttons" style="display:none;flex-direction:row;gap:6px;margin-bottom:6px">
      <button class="touch-btn ability-btn" id="btn-ability-1" style="width:48px;height:48px;font-size:18px;border-color:rgba(255,152,0,0.6);background:rgba(255,152,0,0.12)">üëä</button>
      <button class="touch-btn ability-btn" id="btn-ability-2" style="width:48px;height:48px;font-size:18px;border-color:rgba(66,165,245,0.6);background:rgba(66,165,245,0.12)">üõ°Ô∏è</button>
      <button class="touch-btn ability-btn" id="btn-ability-3" style="width:48px;height:48px;font-size:18px;border-color:rgba(102,187,106,0.6);background:rgba(102,187,106,0.12)">‚ö°</button>
    </div>
    <button class="touch-btn jump-btn" id="btn-jump">&#9650;</button>
    <button class="touch-btn hit-btn" id="btn-hit">HIT</button>
  </div>
</div>

<!-- Touch buttons for menus -->
<div id="touch-menu"></div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = 900;
const H = 550;
canvas.width = W;
canvas.height = H;

// --- Arena ---
const ARENA = {
  left: 60,
  right: W - 60,
  floor: H - 80,
  wallHeight: 260,
};
ARENA.top = ARENA.floor - ARENA.wallHeight;

// --- Constants ---
const GRAVITY = 0.45;
const PLAYER_SPEED = 3.5;
const JUMP_VEL = -9;
const PLAYER_W = 24;
const PLAYER_H = 40;
const BALL_RADIUS = 5;
const BALL_HIT_SPEED = 10;
const BALL_FRICTION_X = 0.993;
const BALL_FRICTION_FLOOR = 0.97;
const BALL_BOUNCE = 0.65;
const BALL_MIN_SPEED = 0.2;
const HIT_RANGE = 50;
const HIT_COOLDOWN = 18;

// --- Input ---
const keys = {};
const justPressed = {};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) justPressed[e.code] = true;
  keys[e.code] = true;
  if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Escape', 'Enter'].includes(e.code)) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// --- Touch support ---
let isTouchDevice = false;
const touchControls = document.getElementById('touch-controls');
const touchMenu = document.getElementById('touch-menu');

// Detect touch device on first touch
window.addEventListener('touchstart', () => { isTouchDevice = true; }, { once: true });

// Map touch buttons to key codes
function setupTouchButton(btnId, keyCode) {
  const btn = document.getElementById(btnId);
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    isTouchDevice = true;
    if (!keys[keyCode]) justPressed[keyCode] = true;
    keys[keyCode] = true;
    btn.classList.add('pressed');
  }, { passive: false });
  btn.addEventListener('touchend', e => {
    e.preventDefault();
    keys[keyCode] = false;
    btn.classList.remove('pressed');
  }, { passive: false });
  btn.addEventListener('touchcancel', e => {
    keys[keyCode] = false;
    btn.classList.remove('pressed');
  });
  // Prevent mouse events on touch buttons
  btn.addEventListener('mousedown', e => e.preventDefault());
}

setupTouchButton('btn-left', 'ArrowLeft');
setupTouchButton('btn-right', 'ArrowRight');
setupTouchButton('btn-jump', 'ArrowUp');
setupTouchButton('btn-hit', 'Space');
setupTouchButton('btn-ability-1', 'Digit1');
setupTouchButton('btn-ability-2', 'Digit2');
setupTouchButton('btn-ability-3', 'Digit3');

// Touch menu helper ‚Äî creates tappable buttons for menu screens
function updateTouchMenu() {
  if (!isTouchDevice) { touchMenu.classList.remove('visible'); return; }

  let html = '';
  if (gameState === 'title') {
    html = '<button class="menu-touch-btn" ontouchstart="justPressed[\'Enter\']=true;keys[\'Enter\']=true;setTimeout(()=>keys[\'Enter\']=false,50)">PLAY</button>';
  } else if (gameState === 'mode') {
    html = '<button class="menu-touch-btn" ontouchstart="selectedMode=0;justPressed[\'Enter\']=true;keys[\'Enter\']=true;setTimeout(()=>keys[\'Enter\']=false,50)">SOLO</button>';
    html += '<button class="menu-touch-btn" ontouchstart="selectedMode=1;justPressed[\'Enter\']=true;keys[\'Enter\']=true;setTimeout(()=>keys[\'Enter\']=false,50)">PUBLIC</button>';
    html += '<br><button class="menu-touch-btn" style="margin-top:8px;font-size:13px;padding:10px 20px;opacity:0.6" ontouchstart="justPressed[\'Escape\']=true;keys[\'Escape\']=true;setTimeout(()=>keys[\'Escape\']=false,50)">BACK</button>';
  } else if (gameState === 'menu') {
    DIFF_KEYS.forEach((k, i) => {
      const d = DIFFICULTIES[k];
      const sel = i === selectedDifficulty ? 'border-color:' + d.color + ';background:rgba(255,255,255,0.2)' : '';
      html += `<button class="menu-touch-btn" style="${sel}" ontouchstart="selectedDifficulty=${i};justPressed['Enter']=true;keys['Enter']=true;setTimeout(()=>keys['Enter']=false,50)">${d.label}</button>`;
    });
    html += '<br><button class="menu-touch-btn" style="margin-top:8px;font-size:13px;padding:10px 20px;opacity:0.6" ontouchstart="justPressed[\'Escape\']=true;keys[\'Escape\']=true;setTimeout(()=>keys[\'Escape\']=false,50)">BACK</button>';
  } else if (gameState === 'gameover') {
    html = '<button class="menu-touch-btn" ontouchstart="justPressed[\'Enter\']=true;keys[\'Enter\']=true;setTimeout(()=>keys[\'Enter\']=false,50)">PLAY AGAIN</button>';
  }

  if (html) {
    touchMenu.innerHTML = html;
    touchMenu.classList.add('visible');
  } else {
    touchMenu.classList.remove('visible');
  }
}

// Show/hide touch controls and menu based on game state
let lastTouchState = '';
function updateTouchUI() {
  if (!isTouchDevice) {
    touchControls.classList.remove('visible');
    touchMenu.classList.remove('visible');
    return;
  }
  const isPlaying = gameState === 'playing' || gameState === 'countdown';
  // Show/hide ability buttons for touch on Impossible mode
  const abilityBtns = document.getElementById('ability-buttons');
  if (abilityBtns) {
    abilityBtns.style.display = (isPlaying && currentDifficulty === DIFFICULTIES.impossible) ? 'flex' : 'none';
    // Grey out used abilities
    if (isPlaying && currentDifficulty === DIFFICULTIES.impossible) {
      const human = players.find(p => p.playerNum === 1 && p.alive);
      if (human) {
        const ids = ['ironfist', 'shield', 'speed'];
        const btnIds = ['btn-ability-1', 'btn-ability-2', 'btn-ability-3'];
        for (let i = 0; i < 3; i++) {
          const btn = document.getElementById(btnIds[i]);
          if (btn) btn.style.opacity = human.abilityAvailable[ids[i]] ? '1' : '0.3';
        }
      }
    }
  }
  if (isPlaying) {
    touchControls.classList.add('visible');
    touchMenu.classList.remove('visible');
  } else {
    touchControls.classList.remove('visible');
    if (lastTouchState !== gameState) {
      updateTouchMenu();
    }
  }
  lastTouchState = gameState;
}

// Prevent double-tap zoom and other touch defaults on the page
document.addEventListener('touchstart', e => {
  if (e.target.tagName === 'CANVAS' || e.target.classList.contains('touch-btn') || e.target.classList.contains('menu-touch-btn')) {
    e.preventDefault();
  }
}, { passive: false });

// --- Difficulty & Mode settings ---
const DIFFICULTIES = {
  easy: {
    label: 'Easy',
    desc: 'Slow AI, fewer opponents',
    color: '#66bb6a',
    aiCount: 2,
    aiSpeedMult: 0.4,
    aiThinkInterval: 40,   // frames between AI decisions
    aiHitDelay: 30,         // extra frames before AI swings
    aiDodgeChance: 0.005,
    aiJumpChance: 0.005,
    aiHitAccuracy: 0.3,
    aiTargetPlayer: 0.2,    // chance to target the human vs random
    ballSpeed: 7,
  },
  medium: {
    label: 'Medium',
    desc: 'Balanced challenge',
    color: '#ffa726',
    aiCount: 3,
    aiSpeedMult: 0.7,
    aiThinkInterval: 15,
    aiHitDelay: 10,
    aiDodgeChance: 0.02,
    aiJumpChance: 0.02,
    aiHitAccuracy: 0.6,
    aiTargetPlayer: 0.4,
    ballSpeed: 9,
  },
  hard: {
    label: 'Hard',
    desc: 'Fast AI, more opponents',
    color: '#ef5350',
    aiCount: 4,
    aiSpeedMult: 1.0,
    aiThinkInterval: 5,
    aiHitDelay: 3,
    aiDodgeChance: 0.06,
    aiJumpChance: 0.05,
    aiHitAccuracy: 0.85,
    aiTargetPlayer: 0.6,
    ballSpeed: 11,
  },
  insane: {
    label: 'Insane',
    desc: 'Ruthless AI, packed arena',
    color: '#ab47bc',
    aiCount: 5,
    aiSpeedMult: 1.2,
    aiThinkInterval: 1,
    aiHitDelay: 0,
    aiDodgeChance: 0.12,
    aiJumpChance: 0.08,
    aiHitAccuracy: 0.95,
    aiTargetPlayer: 0.8,
    ballSpeed: 13,
  },
  impossible: {
    label: 'Impossible',
    desc: 'You will not survive',
    color: '#f44336',
    aiCount: 5,
    aiSpeedMult: 1.6,
    aiThinkInterval: 1,
    aiHitDelay: 0,
    aiDodgeChance: 0.25,
    aiJumpChance: 0.15,
    aiHitAccuracy: 1.0,
    aiTargetPlayer: 1.0,
    ballSpeed: 17,
  },
};
const DIFF_KEYS = ['easy', 'medium', 'hard', 'insane', 'impossible'];
let selectedDifficulty = 1; // index into DIFF_KEYS
let currentDifficulty = DIFFICULTIES.medium;

// --- Game mode ---
let gameMode = 'solo'; // 'solo' or 'public'

// --- Game state ---
let gameState = 'title'; // title, mode, menu, countdown, playing, gameover
let countdownTimer = 0;
let players = [];
let ball = null;
let particles = [];
let prevAlive = [];
let gagaBounceCount = 0;
let gagaText = '';
let gagaTextTimer = 0;
let gagaBallCanBounce = true;
let p2HasInput = false; // tracks if P2 has pressed any key during countdown

// --- Abilities (Impossible mode only) ---
let frameCount = 0;
// Ability definitions
const ABILITIES = [
  { id: 'ironfist', label: 'Iron Fist', icon: 'üëä', color: '#ff9800', key: '1', desc: '2x hit power' },
  { id: 'shield', label: 'Shield', icon: 'üõ°Ô∏è', color: '#42a5f5', key: '2', desc: 'Block 1 hit' },
  { id: 'speed', label: 'Speed', icon: '‚ö°', color: '#66bb6a', key: '3', desc: '5s speed boost' },
];

// --- Colors ---
const COLORS = ['#4fc3f7', '#ef5350', '#66bb6a', '#ffa726', '#ab47bc', '#ec407a'];
const SKIN = ['#ffcc99', '#e8b88a', '#c8956c', '#ffcc99', '#f0c8a0', '#ffe0bd'];
const NAMES = ['You', 'Red', 'Green', 'Orange', 'Purple', 'Pink'];

// --- Entity creation ---
// playerNum: 0 = AI, 1 = human player 1 (WASD+Space), 2 = human player 2 (Arrows+Enter)
function createPlayer(index, x, playerNum) {
  const diff = currentDifficulty;
  const isHuman = playerNum > 0;
  return {
    x, y: ARENA.floor - PLAYER_H / 2,
    vx: 0, vy: 0,
    w: PLAYER_W, h: PLAYER_H,
    color: COLORS[index % COLORS.length],
    skin: SKIN[index % SKIN.length],
    name: NAMES[index % NAMES.length],
    isHuman,
    playerNum,  // 0=AI, 1=P1, 2=P2
    alive: true,
    onGround: true,
    facing: index < 2 ? 1 : -1,
    hitCooldown: 0,
    canHitBall: true,
    // AI ‚Äî tuned by difficulty
    aiTimer: Math.floor(Math.random() * 60),  // stagger AI thinking
    aiThinkInterval: isHuman ? 0 : diff.aiThinkInterval,
    aiCanAct: false,          // set to true on think frames
    aiHitDelay: isHuman ? 0 : diff.aiHitDelay,
    aiHitWait: 0,             // countdown before AI actually swings
    aiSpeedMult: isHuman ? 1 : diff.aiSpeedMult,
    aiDodgeChance: isHuman ? 0 : diff.aiDodgeChance,
    aiJumpChance: isHuman ? 0 : diff.aiJumpChance,
    aiHitAccuracy: isHuman ? 1 : diff.aiHitAccuracy,
    aiTargetPlayer: isHuman ? 0 : diff.aiTargetPlayer,
    aiIdleTimer: 0,           // random idle pauses
    aiMoveDir: 0,             // -1, 0, or 1 ‚Äî persists between think frames
    // Animation
    walkFrame: 0,
    hitAnim: 0,
    // Abilities (Impossible mode)
    hasIronFist: false,
    hasShield: false,
    speedBoostTimer: 0,
    // Track which abilities are still available (one-time use)
    abilityAvailable: { ironfist: true, shield: true, speed: true },
  };
}

function createBall() {
  return {
    x: W / 2,
    y: ARENA.floor - 100,
    vx: 0,
    vy: 0,
    radius: BALL_RADIUS,
    dangerous: false,
    lastHitBy: null,
    bounced: false,
    glowIntensity: 0,
  };
}

function initGame() {
  currentDifficulty = DIFFICULTIES[DIFF_KEYS[selectedDifficulty]];
  players = [];
  const humanCount = gameMode === 'public' ? 2 : 1;
  const totalPlayers = currentDifficulty.aiCount + humanCount;
  // Randomize spawn positions
  const minX = ARENA.left + 40;
  const maxX = ARENA.right - 40;
  const positions = [];
  const minGap = 50; // minimum space between players
  for (let i = 0; i < totalPlayers; i++) {
    let x, attempts = 0;
    do {
      x = minX + Math.random() * (maxX - minX);
      attempts++;
    } while (attempts < 100 && positions.some(px => Math.abs(px - x) < minGap));
    positions.push(x);
  }
  for (let i = 0; i < totalPlayers; i++) {
    let playerNum = 0; // AI
    if (i === 0) playerNum = 1; // P1
    else if (i === 1 && gameMode === 'public') playerNum = 2; // P2
    players.push(createPlayer(i, positions[i], playerNum));
  }
  // Set names for public mode
  if (gameMode === 'public') {
    players[0].name = 'P1';
    players[1].name = 'P2';
  }
  ball = createBall();
  ball.y = ARENA.top + 20; // start ball high up
  ball.vy = 0;
  ball.vx = 0;
  particles = [];
  frameCount = 0;
  gameState = 'countdown';
  countdownTimer = 0;
  gagaBounceCount = 0;
  gagaText = '';
  gagaTextTimer = 0;
  gagaBallCanBounce = true;
  p2HasInput = false;
}

function convertToAI(p) {
  const diff = currentDifficulty;
  p.isHuman = false;
  p.playerNum = 0;
  p.aiThinkInterval = diff.aiThinkInterval;
  p.aiHitDelay = diff.aiHitDelay;
  p.aiSpeedMult = diff.aiSpeedMult;
  p.aiDodgeChance = diff.aiDodgeChance;
  p.aiJumpChance = diff.aiJumpChance;
  p.aiHitAccuracy = diff.aiHitAccuracy;
  p.aiTargetPlayer = diff.aiTargetPlayer;
}

// --- Physics helpers ---
function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

function playerRect(p) {
  return { left: p.x - p.w / 2, right: p.x + p.w / 2, top: p.y - p.h / 2, bottom: p.y + p.h / 2 };
}

function circleRectOverlap(cx, cy, cr, rect) {
  const closestX = clamp(cx, rect.left, rect.right);
  const closestY = clamp(cy, rect.top, rect.bottom);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx * dx + dy * dy) < (cr * cr);
}

// --- Update ---
function updatePlayer(p) {
  if (!p.alive) return;
  if (p.hitCooldown > 0) p.hitCooldown--;
  if (p.hitAnim > 0) p.hitAnim--;

  if (p.isHuman) {
    updateHuman(p);
  } else {
    updateAI(p);
  }

  // Gravity
  p.vy += GRAVITY;
  p.y += p.vy;
  p.x += p.vx;
  p.vx *= 0.85;

  // Floor
  if (p.y + p.h / 2 >= ARENA.floor) {
    p.y = ARENA.floor - p.h / 2;
    p.vy = 0;
    p.onGround = true;
  } else {
    p.onGround = false;
  }

  // Walls
  if (p.x - p.w / 2 < ARENA.left) { p.x = ARENA.left + p.w / 2; p.vx = 0; }
  if (p.x + p.w / 2 > ARENA.right) { p.x = ARENA.right - p.w / 2; p.vx = 0; }

  // Walk animation
  const isMoving = p.isHuman && (
    (p.playerNum !== 2 && (keys['KeyA'] || keys['KeyD'])) ||
    (p.playerNum !== 1 && (keys['ArrowLeft'] || keys['ArrowRight']))
  );
  if (Math.abs(p.vx) > 0.5 || isMoving) {
    p.walkFrame += 0.15;
  } else {
    p.walkFrame = 0;
  }
}

function updateHuman(p) {
  // Speed Boost power-up
  const speed = p.speedBoostTimer > 0 ? PLAYER_SPEED * 1.5 : PLAYER_SPEED;
  if (p.speedBoostTimer > 0) p.speedBoostTimer--;

  // Ability activation (Impossible mode only, keys 1/2/3)
  if (currentDifficulty === DIFFICULTIES.impossible && p.alive) {
    if (justPressed['Digit1'] && p.abilityAvailable.ironfist && !p.hasIronFist) {
      p.hasIronFist = true;
      p.abilityAvailable.ironfist = false;
      spawnAbilityParticles(p.x, p.y, '#ff9800');
    }
    if (justPressed['Digit2'] && p.abilityAvailable.shield && !p.hasShield) {
      p.hasShield = true;
      p.abilityAvailable.shield = false;
      spawnAbilityParticles(p.x, p.y, '#42a5f5');
    }
    if (justPressed['Digit3'] && p.abilityAvailable.speed && p.speedBoostTimer <= 0) {
      p.speedBoostTimer = 300;
      p.abilityAvailable.speed = false;
      spawnAbilityParticles(p.x, p.y, '#66bb6a');
    }
  }

  if (p.playerNum === 1 && gameMode === 'public') {
    // Public mode P1: WASD + Space only
    if (keys['KeyA']) { p.x -= speed; p.facing = -1; }
    if (keys['KeyD']) { p.x += speed; p.facing = 1; }
    if (justPressed['KeyW'] && p.onGround) { p.vy = JUMP_VEL; p.onGround = false; }
    if (keys['Space'] && p.hitCooldown <= 0) {
      tryHitBall(p); p.hitCooldown = HIT_COOLDOWN; p.hitAnim = 10;
    }
  } else if (p.playerNum === 2) {
    // Public mode P2: Arrows + Enter
    if (keys['ArrowLeft']) { p.x -= speed; p.facing = -1; }
    if (keys['ArrowRight']) { p.x += speed; p.facing = 1; }
    if (justPressed['ArrowUp'] && p.onGround) { p.vy = JUMP_VEL; p.onGround = false; }
    if (keys['Enter'] && p.hitCooldown <= 0) {
      tryHitBall(p); p.hitCooldown = HIT_COOLDOWN; p.hitAnim = 10;
    }
  } else {
    // Solo mode: both WASD and Arrows work
    if (keys['ArrowLeft'] || keys['KeyA']) { p.x -= speed; p.facing = -1; }
    if (keys['ArrowRight'] || keys['KeyD']) { p.x += speed; p.facing = 1; }
    if ((justPressed['ArrowUp'] || justPressed['KeyW']) && p.onGround) { p.vy = JUMP_VEL; p.onGround = false; }
    if (keys['Space'] && p.hitCooldown <= 0) {
      tryHitBall(p); p.hitCooldown = HIT_COOLDOWN; p.hitAnim = 10;
    }
  }
}

function updateAI(p) {
  if (!ball) return;
  p.aiTimer++;
  if (p.aiHitWait > 0) p.aiHitWait--;
  if (p.aiIdleTimer > 0) { p.aiIdleTimer--; p.aiMoveDir = 0; return; }

  // AI makes NEW decisions only on think frames (slower = dumber)
  // but keeps moving in their chosen direction every frame
  const canThink = (p.aiTimer % p.aiThinkInterval) === 0;

  // Speed Boost power-up for AI
  if (p.speedBoostTimer > 0) p.speedBoostTimer--;

  const dx = ball.x - p.x;
  const dy = ball.y - p.y;
  const distToBall = Math.sqrt(dx * dx + dy * dy);
  const ballSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  const speedMult = p.speedBoostTimer > 0 ? 1.5 : 1;
  const aiSpeed = PLAYER_SPEED * p.aiSpeedMult * speedMult;

  // Is ball coming at me?
  const ballHeadingToMe = ball.dangerous && ballSpeed > 2 &&
    Math.sign(ball.vx) === Math.sign(p.x - ball.x) &&
    Math.abs(ball.y - p.y) < 80 &&
    Math.abs(ball.x - p.x) < 200;

  // --- DECISIONS (only on think frames) ---
  if (canThink) {
    if (ballHeadingToMe) {
      // Decide to dodge
      if (p.onGround && Math.abs(ball.x - p.x) < 120 && Math.random() < p.aiDodgeChance) {
        p.vy = JUMP_VEL;
        p.onGround = false;
      }
      // Move away from ball
      p.aiMoveDir = ball.x < p.x ? 1 : -1;
    } else if (distToBall < HIT_RANGE && p.canHitBall && p.hitCooldown <= 0 && ball.y > ARENA.top) {
      // Close to ball ‚Äî try to hit it
      if (p.aiHitWait <= 0) {
        let target = null;
        if (Math.random() < p.aiHitAccuracy) {
          const alive = players.filter(o => o !== p && o.alive);
          if (alive.length > 0) {
            if (Math.random() < p.aiTargetPlayer) {
              target = alive.find(o => o.isHuman) || alive[0];
            } else {
              target = alive[Math.floor(Math.random() * alive.length)];
            }
          }
        }
        if (target) {
          p.facing = target.x > p.x ? 1 : -1;
        } else {
          p.facing = Math.random() < 0.5 ? 1 : -1;
        }
        tryHitBall(p);
        p.hitCooldown = HIT_COOLDOWN;
        p.hitAnim = 10;
        p.aiMoveDir = 0;
        p.aiIdleTimer = Math.floor(Math.random() * p.aiThinkInterval * 0.5);
      } else {
        p.aiMoveDir = 0; // stand near ball waiting
      }
    } else {
      // Decide direction toward ball
      if (Math.abs(dx) > 30) {
        p.aiMoveDir = dx > 0 ? 1 : -1;
      } else {
        p.aiMoveDir = 0;
      }
      // Jump if ball is above
      if (ball.y < p.y - 40 && distToBall < 100 && p.onGround && Math.random() < p.aiJumpChance) {
        p.vy = JUMP_VEL;
        p.onGround = false;
      }
    }

    // Start hit delay if near ball and haven't started yet
    if (distToBall < HIT_RANGE && p.canHitBall && p.hitCooldown <= 0 && p.aiHitWait <= 0 && ball.y > ARENA.top) {
      p.aiHitWait = p.aiHitDelay;
    }
  }

  // --- MOVEMENT (every frame, using last decision) ---
  if (p.aiMoveDir !== 0) {
    p.x += p.aiMoveDir * aiSpeed;
    p.facing = p.aiMoveDir;
  }
}

function tryHitBall(p) {
  if (!ball || !p.canHitBall) return;
  const dx = ball.x - p.x;
  const dy = ball.y - (p.y - 5);
  const d = Math.sqrt(dx * dx + dy * dy);
  if (d < HIT_RANGE) {
    // Hit in facing direction ‚Äî keep ball low (gaga ball is a ground game)
    let hitSpeed = currentDifficulty.ballSpeed;
    // Iron Fist power-up: 2x hit speed, then consumed
    if (p.hasIronFist) {
      hitSpeed *= 2;
      p.hasIronFist = false;
      // Orange burst particles on iron fist hit
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd = 2 + Math.random() * 3;
        particles.push({
          x: ball.x, y: ball.y,
          vx: Math.cos(angle) * spd,
          vy: Math.sin(angle) * spd - 1,
          life: 15 + Math.random() * 15,
          maxLife: 30,
          color: '#ff9800',
          radius: 2 + Math.random() * 3,
        });
      }
    }
    ball.vx = p.facing * hitSpeed;
    ball.vy = -2;  // tiny upward pop, stays near ground level
    ball.dangerous = true;
    ball.lastHitBy = p;
    ball.bounced = false;
    ball.glowIntensity = 1;

    for (const pl of players) pl.canHitBall = true;
    p.canHitBall = false;
  }
}

function updateBall() {
  if (!ball) return;

  // Gravity
  ball.vy += GRAVITY;

  ball.x += ball.vx;
  ball.y += ball.vy;

  // Friction
  ball.vx *= BALL_FRICTION_X;

  // Glow decay
  ball.glowIntensity *= 0.97;

  // Floor bounce
  if (ball.y + ball.radius >= ARENA.floor) {
    ball.y = ARENA.floor - ball.radius;
    ball.vy = -Math.abs(ball.vy) * BALL_BOUNCE;
    ball.vx *= BALL_FRICTION_FLOOR;
    if (Math.abs(ball.vy) < 1.5) ball.vy = 0;

    ball.bounced = true;
    ball.glowIntensity = Math.min(ball.glowIntensity + 0.2, 1);
  }

  // Wall bounces
  if (ball.x - ball.radius < ARENA.left) {
    ball.x = ARENA.left + ball.radius;
    ball.vx = Math.abs(ball.vx) * 0.85;
    ball.bounced = true;
    ball.glowIntensity = Math.min(ball.glowIntensity + 0.2, 1);
  }
  if (ball.x + ball.radius > ARENA.right) {
    ball.x = ARENA.right - ball.radius;
    ball.vx = -Math.abs(ball.vx) * 0.85;
    ball.bounced = true;
    ball.glowIntensity = Math.min(ball.glowIntensity + 0.2, 1);
  }

  // Stop if too slow
  const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  if (speed < BALL_MIN_SPEED && ball.y + ball.radius >= ARENA.floor - 1) {
    ball.vx = 0;
    ball.vy = 0;
    ball.dangerous = false;
  }

  // Player collision (elimination ‚Äî only hits at knees or below count)
  if (ball.dangerous) {
    for (const p of players) {
      if (!p.alive) continue;
      if (ball.lastHitBy === p && !ball.bounced) continue;
      // Legs zone: from knees down to feet
      const kneeY = p.y + p.h * 0.15;  // knees are ~60% down the body
      const feetY = p.y + p.h / 2;
      const legRect = { left: p.x - p.w / 2 - 2, right: p.x + p.w / 2 + 2, top: kneeY, bottom: feetY };
      if (circleRectOverlap(ball.x, ball.y, ball.radius, legRect)) {
        // Shield power-up: absorb one hit
        if (p.hasShield) {
          p.hasShield = false;
          ball.vx *= -0.4;
          ball.vy = -3;
          ball.dangerous = false;
          ball.glowIntensity = 0;
          // Blue shield break particles
          for (let i = 0; i < 16; i++) {
            const angle = Math.random() * Math.PI * 2;
            const spd = 2 + Math.random() * 4;
            particles.push({
              x: p.x, y: p.y,
              vx: Math.cos(angle) * spd,
              vy: Math.sin(angle) * spd - 2,
              life: 25 + Math.random() * 25,
              maxLife: 50,
              color: '#42a5f5',
              radius: 2 + Math.random() * 4,
            });
          }
          break;
        }
        p.alive = false;
        spawnParticles(p.x, feetY, p.color);
        ball.vx *= 0.3;
        ball.vy *= 0.3;
        ball.dangerous = false;
        ball.glowIntensity = 0;
        break;
      }
    }
  }
}

function checkGameOver() {
  const alive = players.filter(p => p.alive);
  if (alive.length <= 1) gameState = 'gameover';
}

// --- Particles ---
function spawnParticles(x, y, color) {
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      life: 30 + Math.random() * 30,
      maxLife: 60,
      color,
      radius: 2 + Math.random() * 3,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.vy += 0.1;
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// --- Abilities ---
function spawnAbilityParticles(x, y, color) {
  for (let i = 0; i < 10; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd - 2,
      life: 20 + Math.random() * 15,
      maxLife: 35,
      color,
      radius: 2 + Math.random() * 3,
    });
  }
}

function drawAbilityHUD() {
  if (currentDifficulty !== DIFFICULTIES.impossible) return;
  // Find the human player (P1)
  const human = players.find(p => p.playerNum === 1 && p.alive);
  if (!human) return;

  const hudX = W - 15;  // right-aligned
  const hudY = 50;
  const boxW = 44;
  const boxH = 44;
  const gap = 8;

  ctx.textAlign = 'center';

  for (let i = 0; i < ABILITIES.length; i++) {
    const ab = ABILITIES[i];
    const x = hudX - (ABILITIES.length - i) * (boxW + gap) + boxW / 2;
    const y = hudY;

    const available = human.abilityAvailable[ab.id];
    const active = (ab.id === 'ironfist' && human.hasIronFist) ||
                   (ab.id === 'shield' && human.hasShield) ||
                   (ab.id === 'speed' && human.speedBoostTimer > 0);
    const used = !available && !active;

    // Box background
    ctx.beginPath();
    ctx.roundRect(x - boxW / 2, y, boxW, boxH, 6);
    if (active) {
      ctx.fillStyle = ab.color + '40';
      ctx.fill();
      ctx.strokeStyle = ab.color;
      ctx.lineWidth = 2;
      ctx.stroke();
      // Glow
      ctx.shadowColor = ab.color;
      ctx.shadowBlur = 10;
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (available) {
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
    } else {
      // Used up
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Icon
    ctx.globalAlpha = used ? 0.25 : 1;
    ctx.font = '18px sans-serif';
    ctx.fillText(ab.icon, x, y + 26);

    // Key hint
    if (!isTouchDevice) {
      ctx.font = 'bold 10px sans-serif';
      ctx.fillStyle = used ? 'rgba(255,255,255,0.15)' : (active ? ab.color : 'rgba(255,255,255,0.45)');
      ctx.fillText(`[${ab.key}]`, x, y + 42);
    }

    // Speed boost timer bar
    if (ab.id === 'speed' && human.speedBoostTimer > 0) {
      const barW2 = boxW - 8;
      const barH2 = 3;
      const barX2 = x - barW2 / 2;
      const barY2 = y + boxH - 6;
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(barX2, barY2, barW2, barH2);
      ctx.fillStyle = ab.color;
      ctx.fillRect(barX2, barY2, barW2 * (human.speedBoostTimer / 300), barH2);
    }

    // "USED" X overlay
    if (used) {
      ctx.font = 'bold 16px sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillText('‚úï', x, y + 28);
    }

    ctx.globalAlpha = 1;
  }
}

// --- Drawing ---
function drawArena() {
  // Sky gradient
  const sky = ctx.createLinearGradient(0, 0, 0, ARENA.floor);
  sky.addColorStop(0, '#0d1b2a');
  sky.addColorStop(1, '#1b2838');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, ARENA.floor);

  // Floor
  ctx.fillStyle = '#3a3a5c';
  ctx.fillRect(ARENA.left, ARENA.floor, ARENA.right - ARENA.left, H - ARENA.floor);

  // Floor lines
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  for (let x = ARENA.left; x < ARENA.right; x += 40) {
    ctx.beginPath();
    ctx.moveTo(x, ARENA.floor);
    ctx.lineTo(x, H);
    ctx.stroke();
  }

  // Floor surface line
  ctx.strokeStyle = '#5c6bc0';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(ARENA.left, ARENA.floor);
  ctx.lineTo(ARENA.right, ARENA.floor);
  ctx.stroke();

  // Left wall
  ctx.fillStyle = '#2a2a44';
  ctx.fillRect(ARENA.left - 12, ARENA.top, 12, ARENA.wallHeight);
  ctx.strokeStyle = '#5c6bc0';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(ARENA.left, ARENA.top);
  ctx.lineTo(ARENA.left, ARENA.floor);
  ctx.stroke();

  // Right wall
  ctx.fillStyle = '#2a2a44';
  ctx.fillRect(ARENA.right, ARENA.top, 12, ARENA.wallHeight);
  ctx.strokeStyle = '#5c6bc0';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(ARENA.right, ARENA.top);
  ctx.lineTo(ARENA.right, ARENA.floor);
  ctx.stroke();

  // Wall glow
  ctx.strokeStyle = 'rgba(92, 107, 192, 0.15)';
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(ARENA.left, ARENA.top);
  ctx.lineTo(ARENA.left, ARENA.floor);
  ctx.lineTo(ARENA.right, ARENA.floor);
  ctx.lineTo(ARENA.right, ARENA.top);
  ctx.stroke();

  // Wall top caps
  ctx.fillStyle = '#7986cb';
  ctx.fillRect(ARENA.left - 14, ARENA.top - 4, 16, 8);
  ctx.fillRect(ARENA.right - 2, ARENA.top - 4, 16, 8);

  // Below arena
  ctx.fillStyle = '#252540';
  ctx.fillRect(0, ARENA.floor, ARENA.left, H - ARENA.floor);
  ctx.fillRect(ARENA.right, ARENA.floor, W - ARENA.right, H - ARENA.floor);
}

function drawPlayer(p) {
  const footY = p.y + p.h / 2;
  const headY = p.y - p.h / 2;
  const centerY = p.y;

  // Shadow on ground
  if (!p.onGround) {
    ctx.beginPath();
    ctx.ellipse(p.x, ARENA.floor, p.w * 0.5, 4, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fill();
  }

  // Legs (walk animation)
  const legSwing = p.onGround ? Math.sin(p.walkFrame * 3) * 5 : 3;
  ctx.strokeStyle = p.color;
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  // Left leg
  ctx.beginPath();
  ctx.moveTo(p.x - 4, centerY + 8);
  ctx.lineTo(p.x - 4 + legSwing, footY);
  ctx.stroke();
  // Right leg
  ctx.beginPath();
  ctx.moveTo(p.x + 4, centerY + 8);
  ctx.lineTo(p.x + 4 - legSwing, footY);
  ctx.stroke();

  // Body
  ctx.fillStyle = p.color;
  ctx.beginPath();
  ctx.roundRect(p.x - 10, centerY - 10, 20, 22, 4);
  ctx.fill();

  // Arms
  const armAngle = p.hitAnim > 0 ? p.facing * 12 : 0;
  ctx.strokeStyle = p.skin;
  ctx.lineWidth = 4;
  // Back arm
  ctx.beginPath();
  ctx.moveTo(p.x - p.facing * 6, centerY - 2);
  ctx.lineTo(p.x - p.facing * 14, centerY + 6);
  ctx.stroke();
  // Front arm (swings when hitting)
  ctx.beginPath();
  ctx.moveTo(p.x + p.facing * 6, centerY - 2);
  ctx.lineTo(p.x + p.facing * 18 + armAngle, centerY - 4 - (p.hitAnim > 0 ? 8 : 0));
  ctx.stroke();
  // Hand
  if (p.hitAnim > 0) {
    ctx.beginPath();
    ctx.arc(p.x + p.facing * 18 + armAngle, centerY - 12, 4, 0, Math.PI * 2);
    ctx.fillStyle = p.skin;
    ctx.fill();
  }

  // Head
  ctx.beginPath();
  ctx.arc(p.x, headY + 6, 10, 0, Math.PI * 2);
  ctx.fillStyle = p.skin;
  ctx.fill();

  // Eyes
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(p.x + p.facing * 3, headY + 4, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(p.x + p.facing * 7, headY + 4, 2, 0, Math.PI * 2);
  ctx.fill();

  // --- Power-up visual indicators ---
  // Shield aura
  if (p.hasShield) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.h * 0.65, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(66, 165, 245, 0.4)';
    ctx.lineWidth = 2;
    ctx.stroke();
    const shieldGlow = ctx.createRadialGradient(p.x, p.y, p.h * 0.3, p.x, p.y, p.h * 0.65);
    shieldGlow.addColorStop(0, 'rgba(66, 165, 245, 0)');
    shieldGlow.addColorStop(1, 'rgba(66, 165, 245, 0.12)');
    ctx.fillStyle = shieldGlow;
    ctx.fill();
  }

  // Iron Fist glow on front hand
  if (p.hasIronFist) {
    const handX = p.x + p.facing * 18 + (p.hitAnim > 0 ? p.facing * 12 : 0);
    const handY = centerY - (p.hitAnim > 0 ? 12 : 4);
    const fistGlow = ctx.createRadialGradient(handX, handY, 2, handX, handY, 12);
    fistGlow.addColorStop(0, 'rgba(255, 152, 0, 0.6)');
    fistGlow.addColorStop(1, 'rgba(255, 152, 0, 0)');
    ctx.beginPath();
    ctx.arc(handX, handY, 12, 0, Math.PI * 2);
    ctx.fillStyle = fistGlow;
    ctx.fill();
  }

  // Speed Boost trail
  if (p.speedBoostTimer > 0 && Math.abs(p.vx) > 0.3) {
    for (let i = 1; i <= 3; i++) {
      const trailAlpha = (0.25 - i * 0.07);
      ctx.globalAlpha = trailAlpha;
      ctx.beginPath();
      ctx.arc(p.x - p.vx * i * 3, footY - p.h * 0.3, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#66bb6a';
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Name tag
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = p.color;
  ctx.fillText(p.name, p.x, headY - 8);
}

function drawBall() {
  if (!ball) return;

  // Glow
  if (ball.dangerous && ball.glowIntensity > 0.1) {
    const g = ctx.createRadialGradient(ball.x, ball.y, ball.radius, ball.x, ball.y, ball.radius + 25 * ball.glowIntensity);
    g.addColorStop(0, `rgba(255, 87, 34, ${ball.glowIntensity * 0.4})`);
    g.addColorStop(1, 'rgba(255, 87, 34, 0)');
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius + 25 * ball.glowIntensity, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
  }

  // Shadow
  ctx.beginPath();
  ctx.ellipse(ball.x, ARENA.floor, ball.radius * 0.8, 3, 0, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fill();

  // Ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = ball.dangerous ? '#ff5722' : '#e0e0e0';
  ctx.fill();
  ctx.strokeStyle = ball.dangerous ? '#d84315' : '#bdbdbd';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Highlight
  ctx.beginPath();
  ctx.arc(ball.x - 3, ball.y - 3, ball.radius * 0.3, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fill();
}

function drawParticles() {
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawHUD() {
  const alive = players.filter(p => p.alive);

  ctx.font = '13px sans-serif';
  ctx.textAlign = 'left';
  let y = 22;
  for (const p of players) {
    const a = p.alive ? 1 : 0.3;
    ctx.fillStyle = `rgba(255,255,255,${a})`;
    ctx.fillText(p.alive ? '‚óè' : '‚úï', 12, y);
    ctx.fillStyle = p.alive ? p.color : `rgba(128,128,128,${a})`;
    ctx.fillText(p.name, 28, y);
    y += 20;
  }

  ctx.font = 'bold 15px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillStyle = '#fff';
  ctx.fillText(`${alive.length} remaining`, W - 15, 22);

  if (gameState === 'playing' && !isTouchDevice) {
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    if (gameMode === 'public') {
      ctx.fillText('P1: A/D Move, W Jump, Space Hit  |  P2: Arrows Move, Up Jump, Enter Hit', W / 2, H - 10);
    } else if (currentDifficulty === DIFFICULTIES.impossible) {
      ctx.fillText('A/D or Arrows: Move  |  W/Up: Jump  |  Space: Hit  |  1: Iron Fist  2: Shield  3: Speed', W / 2, H - 10);
    } else {
      ctx.fillText('A/D or Arrows: Move  |  W/Up: Jump  |  Space: Hit Ball', W / 2, H - 10);
    }
  }
}

let selectedMode = 0; // 0 = Solo, 1 = Public

function drawTitle() {
  ctx.fillStyle = 'rgba(26, 26, 46, 0.85)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = 'bold 64px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#5c6bc0';
  ctx.fillText('GAGA BALL', W / 2, H / 2 - 80);

  ctx.font = '20px sans-serif';
  ctx.fillStyle = '#9fa8da';
  ctx.fillText('Last one standing wins!', W / 2, H / 2 - 35);

  ctx.font = '15px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  const instr = isTouchDevice ? [
    'Use on-screen buttons to play',
    'Hit opponents with the ball to eliminate them',
  ] : [
    'A/D or Arrow Keys to move left/right',
    'W / Up to jump',
    'Space to hit the ball',
    'Hit opponents with the ball to eliminate them',
  ];
  instr.forEach((t, i) => ctx.fillText(t, W / 2, H / 2 + 10 + i * 26));

  if (!isTouchDevice) {
    ctx.font = 'bold 22px sans-serif';
    ctx.fillStyle = `rgba(255,255,255,${0.5 + Math.sin(Date.now() / 400) * 0.3})`;
    ctx.fillText('Press ENTER to Play', W / 2, H / 2 + 150);
  }
}

function drawModeSelect() {
  ctx.fillStyle = 'rgba(26, 26, 46, 0.92)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = 'bold 42px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#5c6bc0';
  ctx.fillText('SELECT MODE', W / 2, 100);

  const modes = [
    { label: 'Solo', desc: 'You vs AI opponents', icon: '1P', color: '#4fc3f7', details: [] },
    { label: 'Public', desc: '2 players on same device', icon: '2P', color: '#66bb6a',
      details: isTouchDevice ? ['Share the screen!', 'P2 uses a keyboard'] : ['P1: A/D + W + Space', 'P2: Arrows + Enter'] },
  ];

  const cardW = 200;
  const cardH = 220;
  const gap = 40;
  const totalW = modes.length * cardW + (modes.length - 1) * gap;
  const startX = (W - totalW) / 2;
  const cardY = 150;

  for (let i = 0; i < modes.length; i++) {
    const m = modes[i];
    const x = startX + i * (cardW + gap);
    const sel = i === selectedMode;

    // Card background
    ctx.fillStyle = sel ? 'rgba(255,255,255,0.12)' : 'rgba(255,255,255,0.04)';
    ctx.beginPath();
    ctx.roundRect(x, cardY, cardW, cardH, 10);
    ctx.fill();

    if (sel) {
      ctx.strokeStyle = m.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(x, cardY, cardW, cardH, 10);
      ctx.stroke();
      ctx.shadowColor = m.color;
      ctx.shadowBlur = 15;
      ctx.strokeStyle = m.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(x, cardY, cardW, cardH, 10);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Icon
    ctx.font = 'bold 40px sans-serif';
    ctx.fillStyle = sel ? m.color : 'rgba(255,255,255,0.4)';
    ctx.fillText(m.icon, x + cardW / 2, cardY + 60);

    // Label
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = sel ? m.color : 'rgba(255,255,255,0.5)';
    ctx.fillText(m.label, x + cardW / 2, cardY + 100);

    // Description
    ctx.font = '13px sans-serif';
    ctx.fillStyle = sel ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.35)';
    ctx.fillText(m.desc, x + cardW / 2, cardY + 130);

    // Control details (for Public mode)
    if (m.details.length > 0) {
      ctx.font = '11px sans-serif';
      ctx.fillStyle = sel ? 'rgba(255,255,255,0.55)' : 'rgba(255,255,255,0.2)';
      m.details.forEach((line, j) => {
        ctx.fillText(line, x + cardW / 2, cardY + 152 + j * 16);
      });
    }

    // Key hint
    ctx.font = 'bold 14px sans-serif';
    ctx.fillStyle = sel ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.15)';
    ctx.fillText(`[${i + 1}]`, x + cardW / 2, cardY + cardH - 15);
  }

  if (!isTouchDevice) {
    ctx.font = '15px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('‚Üê ‚Üí to select', W / 2, cardY + cardH + 50);

    ctx.font = 'bold 20px sans-serif';
    ctx.fillStyle = `rgba(255,255,255,${0.5 + Math.sin(Date.now() / 400) * 0.3})`;
    ctx.fillText('Press ENTER to Continue', W / 2, cardY + cardH + 90);

    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText('ESC to go back', W / 2, H - 20);
  }
}

function drawMenu() {
  ctx.fillStyle = 'rgba(26, 26, 46, 0.92)';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.font = 'bold 42px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#5c6bc0';
  ctx.fillText('SELECT DIFFICULTY', W / 2, 80);

  // Difficulty cards
  const cardW = 140;
  const cardH = 180;
  const gap = 15;
  const totalW = DIFF_KEYS.length * cardW + (DIFF_KEYS.length - 1) * gap;
  const startX = (W - totalW) / 2;
  const cardY = 130;

  for (let i = 0; i < DIFF_KEYS.length; i++) {
    const diff = DIFFICULTIES[DIFF_KEYS[i]];
    const x = startX + i * (cardW + gap);
    const selected = i === selectedDifficulty;

    // Card background
    ctx.fillStyle = selected ? 'rgba(255,255,255,0.12)' : 'rgba(255,255,255,0.04)';
    ctx.beginPath();
    ctx.roundRect(x, cardY, cardW, cardH, 10);
    ctx.fill();

    // Selected border
    if (selected) {
      ctx.strokeStyle = diff.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(x, cardY, cardW, cardH, 10);
      ctx.stroke();

      // Glow
      ctx.shadowColor = diff.color;
      ctx.shadowBlur = 15;
      ctx.strokeStyle = diff.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(x, cardY, cardW, cardH, 10);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Difficulty name
    ctx.font = 'bold 22px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = selected ? diff.color : 'rgba(255,255,255,0.5)';
    ctx.fillText(diff.label, x + cardW / 2, cardY + 40);

    // Description
    ctx.font = '13px sans-serif';
    ctx.fillStyle = selected ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.35)';
    ctx.fillText(diff.desc, x + cardW / 2, cardY + 65);

    // Stats
    ctx.font = '12px sans-serif';
    ctx.fillStyle = selected ? 'rgba(255,255,255,0.6)' : 'rgba(255,255,255,0.25)';
    ctx.fillText(`${diff.aiCount} opponents`, x + cardW / 2, cardY + 100);

    // Speed bar
    const barW = 80;
    const barH = 6;
    const barX = x + (cardW - barW) / 2;
    const barY2 = cardY + 120;
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(barX, barY2, barW, barH);
    const fill = Math.min(diff.aiSpeedMult / 1.2, 1);
    ctx.fillStyle = selected ? diff.color : 'rgba(255,255,255,0.25)';
    ctx.fillRect(barX, barY2, barW * fill, barH);
    ctx.font = '10px sans-serif';
    ctx.fillStyle = selected ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.2)';
    ctx.fillText('AI Speed', x + cardW / 2, barY2 + 18);

    // Key hint
    ctx.font = 'bold 14px sans-serif';
    ctx.fillStyle = selected ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.15)';
    ctx.fillText(`[${i + 1}]`, x + cardW / 2, cardY + cardH - 12);
  }

  if (!isTouchDevice) {
    // Instructions
    ctx.font = '15px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText('‚Üê ‚Üí or 1-5 to select', W / 2, cardY + cardH + 50);

    ctx.font = 'bold 20px sans-serif';
    ctx.fillStyle = `rgba(255,255,255,${0.5 + Math.sin(Date.now() / 400) * 0.3})`;
    ctx.fillText('Press ENTER to Start', W / 2, cardY + cardH + 90);

    // Back hint
    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText('ESC to go back', W / 2, H - 20);
  }
}

function drawCountdown() {
  if (gagaTextTimer > 0 && gagaText) {
    const alpha = gagaTextTimer / 40;
    const scale = 1 + (1 - alpha) * 0.3; // text grows slightly as it fades
    ctx.save();
    ctx.translate(W / 2, H / 2 - 20);
    ctx.scale(scale, scale);
    ctx.font = 'bold 90px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillText(gagaText, 0, 0);
    ctx.restore();
  }
  // Show "GO!" briefly after third bounce
  if (gagaBounceCount >= 3 && countdownTimer > 0) {
    const alpha = countdownTimer / 30;
    ctx.font = 'bold 80px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(255, 235, 59, ${alpha})`;
    ctx.fillText('GO!', W / 2, H / 2 - 20);
  }
}

function drawGameOver() {
  const winner = players.find(p => p.alive);

  ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';

  if (winner) {
    ctx.fillStyle = winner.color;
    ctx.fillText(`${winner.name} wins!`, W / 2, H / 2 - 30);
  } else {
    ctx.fillStyle = '#fff';
    ctx.fillText('Draw!', W / 2, H / 2 - 30);
  }

  if (winner && winner.isHuman) {
    ctx.font = '24px sans-serif';
    ctx.fillStyle = '#ffeb3b';
    if (gameMode === 'public') {
      ctx.fillText(`${winner.name} is the champion!`, W / 2, H / 2 + 15);
    } else {
      ctx.fillText('You are the champion!', W / 2, H / 2 + 15);
    }
  } else if (winner) {
    ctx.font = '24px sans-serif';
    ctx.fillStyle = '#ef5350';
    ctx.fillText('Better luck next time!', W / 2, H / 2 + 15);
  }

  if (!isTouchDevice) {
    ctx.font = 'bold 20px sans-serif';
    ctx.fillStyle = `rgba(255,255,255,${0.5 + Math.sin(Date.now() / 400) * 0.3})`;
    ctx.fillText('Press ENTER to Play Again', W / 2, H / 2 + 70);
  }
}

// --- Game loop ---
function gameLoop() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  drawArena();

  switch (gameState) {
    case 'title':
      drawTitle();
      if (justPressed['Enter']) gameState = 'mode';
      break;

    case 'mode':
      drawModeSelect();
      if (justPressed['ArrowLeft'] || justPressed['KeyA']) selectedMode = 0;
      if (justPressed['ArrowRight'] || justPressed['KeyD']) selectedMode = 1;
      if (justPressed['Digit1']) selectedMode = 0;
      if (justPressed['Digit2']) selectedMode = 1;
      if (justPressed['Enter']) {
        gameMode = selectedMode === 0 ? 'solo' : 'public';
        gameState = 'menu';
      }
      if (justPressed['Escape']) gameState = 'title';
      break;

    case 'menu':
      drawMenu();
      if (justPressed['ArrowLeft'] || justPressed['KeyA']) {
        selectedDifficulty = Math.max(0, selectedDifficulty - 1);
      }
      if (justPressed['ArrowRight'] || justPressed['KeyD']) {
        selectedDifficulty = Math.min(DIFF_KEYS.length - 1, selectedDifficulty + 1);
      }
      if (justPressed['Digit1']) selectedDifficulty = 0;
      if (justPressed['Digit2']) selectedDifficulty = 1;
      if (justPressed['Digit3']) selectedDifficulty = 2;
      if (justPressed['Digit4']) selectedDifficulty = 3;
      if (justPressed['Digit5']) selectedDifficulty = 4;
      if (justPressed['Enter']) initGame();
      if (justPressed['Escape']) gameState = 'mode';
      break;

    case 'countdown':
      // In public mode, detect if P2 has pressed any key
      if (gameMode === 'public' && !p2HasInput) {
        if (keys['ArrowLeft'] || keys['ArrowRight'] || keys['ArrowUp'] || keys['Enter']) {
          p2HasInput = true;
        }
      }

      // Ball physics during countdown (gravity + floor bounce)
      ball.vy += GRAVITY;
      ball.y += ball.vy;
      ball.x += ball.vx;

      // Floor bounce ‚Äî count the bounces for GA-GA-BALL
      // Only count a bounce if the ball was above the floor last frame (gagaBallCanBounce)
      if (ball.y + ball.radius >= ARENA.floor) {
        ball.y = ARENA.floor - ball.radius;
        ball.vy = -Math.abs(ball.vy) * 0.85; // higher restitution for visible bounces
        if (gagaBallCanBounce && gagaBounceCount < 3) {
          gagaBounceCount++;
          const words = ['GA', 'GA', 'BALL!'];
          gagaText = words[gagaBounceCount - 1];
          gagaTextTimer = 45;
          gagaBallCanBounce = false; // must leave floor before next bounce counts
          if (gagaBounceCount >= 3) {
            countdownTimer = 40; // brief pause then play
          }
        }
      } else {
        // Ball is above the floor ‚Äî next floor contact can count as a bounce
        gagaBallCanBounce = true;
      }

      // Wall bounces during countdown
      if (ball.x - ball.radius < ARENA.left) {
        ball.x = ARENA.left + ball.radius;
        ball.vx = Math.abs(ball.vx) * 0.85;
      }
      if (ball.x + ball.radius > ARENA.right) {
        ball.x = ARENA.right - ball.radius;
        ball.vx = -Math.abs(ball.vx) * 0.85;
      }

      if (gagaTextTimer > 0) gagaTextTimer--;

      // After the 3rd bounce, count down then start
      if (gagaBounceCount >= 3) {
        countdownTimer--;
        if (countdownTimer <= 0) {
          // If P2 never pressed anything, convert them to AI
          if (gameMode === 'public' && !p2HasInput) {
            const p2 = players.find(p => p.playerNum === 2);
            if (p2) convertToAI(p2);
          }
          gameState = 'playing';
          ball.vx = (Math.random() - 0.5) * 4;
          ball.vy = -2;
          ball.dangerous = false;
          prevAlive = players.map(p => p.alive);
        }
      }

      for (const p of players) drawPlayer(p);
      drawBall();
      drawHUD();
      drawAbilityHUD();
      drawCountdown();
      break;

    case 'playing':
      // Track eliminations
      for (let i = 0; i < players.length; i++) {
        if (prevAlive[i] && !players[i].alive) {
          spawnParticles(players[i].x, players[i].y, players[i].color);
        }
        prevAlive[i] = players[i].alive;
      }

      frameCount++;
      for (const p of players) updatePlayer(p);
      updateBall();
      updateParticles();
      checkGameOver();

      // Draw dead players faintly
      for (const p of players) {
        if (!p.alive) { ctx.globalAlpha = 0.15; drawPlayer(p); ctx.globalAlpha = 1; }
      }
      for (const p of players) {
        if (p.alive) drawPlayer(p);
      }
      drawBall();
      drawParticles();
      drawHUD();
      drawAbilityHUD();
      break;

    case 'gameover':
      for (const p of players) {
        if (!p.alive) { ctx.globalAlpha = 0.15; drawPlayer(p); ctx.globalAlpha = 1; }
      }
      for (const p of players) {
        if (p.alive) drawPlayer(p);
      }
      drawBall();
      updateParticles();
      drawParticles();
      drawHUD();
      drawGameOver();

      if (justPressed['Enter']) initGame();
      break;
  }

  // Update touch UI
  updateTouchUI();

  // Clear justPressed at end of frame
  for (const k in justPressed) justPressed[k] = false;

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
